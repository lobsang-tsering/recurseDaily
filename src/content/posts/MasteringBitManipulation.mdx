---
title: "Bit Manipulation"
pubDate: "May 16 2025"
description: "Thinking patterns to solve leetcode problems."
topics: ["bit manipulation"]
---

# Mastering Bit Manipulation in Java

Welcome to this comprehensive guide to mastering bit manipulation in Java, tailored for LeetCode and competitive programming. Bit manipulation involves operating on numbers at the bit level, leveraging their binary representation to solve problems efficiently. This tutorial takes you from beginner to advanced, covering intuition, philosophy, use cases, pitfalls, and deep insights, with practical Java examples. At the end, you'll find a mind map for quick revision.

## Why Learn Bit Manipulation?

Bit manipulation is a powerful technique for optimizing solutions, especially in competitive programming. It’s used to:
- Solve problems with minimal space complexity (often O(1)).
- Perform operations faster than arithmetic methods.
- Tackle problems involving binary patterns, such as finding unique numbers or detecting duplicates.

**Philosophy**: Think of bit manipulation as a game of toggling switches (0s and 1s). By understanding how to flip, check, or shift these switches, you unlock elegant solutions to complex problems.

## Step 1: Understanding Bits and Binary

### Basics
A bit is the smallest unit of data: `0` or `1`. In Java, integers (`int`) are 32 bits, and longs (`long`) are 64 bits. For example:
- Decimal `5` = Binary `0101`.
- Decimal `-5` = Binary `1111...1011` (two’s complement).

### Key Operators
Java provides bitwise operators to manipulate bits:
- **AND (`&`)**: `1 & 1 = 1`, else `0`.
- **OR (`|`)**: `0 | 0 = 0`, else `1`.
- **XOR (`^`)**: `1 ^ 0 = 1`, `0 ^ 1 = 1`, else `0`.
- **NOT (`~`)**: Flips bits (`~0 = 1`, `~1 = 0`).
- **Left Shift (`<<`)**: Shifts bits left, fills with 0s (e.g., `5 << 1 = 10`, or `1010`).
- **Right Shift (`>>`)**: Shifts bits right, preserves sign bit for signed integers.
- **Unsigned Right Shift (`>>>`)**: Shifts bits right, fills with 0s.

**Intuition**: Imagine bits as a row of light switches. Each operator changes the state of these switches in a specific way.

### Example: Basic Operations
```java
public class BitBasics {
    public static void main(String[] args) {
        int a = 5;  // 0101
        int b = 3;  // 0011
        System.out.println("AND: " + (a & b));  // 0001 = 1
        System.out.println("OR: " + (a | b));   // 0111 = 7
        System.out.println("XOR: " + (a ^ b));  // 0110 = 6
        System.out.println("NOT a: " + (~a));   // ...1010 = -6
        System.out.println("Left Shift: " + (a << 1));  // 1010 = 10
        System.out.println("Right Shift: " + (a >> 1)); // 0010 = 2
    }
}
```

**Key Insight**: Practice converting numbers to binary manually to build intuition. For example, `5 & 3 = 0101 & 0011 = 0001 = 1`.

## Step 2: Core Bit Manipulation Techniques

Let’s explore common techniques with practical examples.

### 1. Checking if a Bit is Set
To check if the `i`-th bit of a number `n` is 1:
- Use `n & (1 << i)`. This creates a mask with a 1 in the `i`-th position.
```java
boolean isBitSet(int n, int i) {
    return (n & (1 << i)) != 0;
}
```
**Use Case**: Check if a number is odd (`n & 1` checks the 0th bit).

### 2. Setting a Bit
To set the `i`-th bit to 1:
- Use `n | (1 << i)`.
```java
int setBit(int n, int i) {
    return n | (1 << i);
}
```
**Use Case**: Enable a flag in a bitmask.

### 3. Clearing a Bit
To set the `i`-th bit to 0:
- Use `n & ~(1 << i)`.
```java
int clearBit(int n, int i) {
    return n & ~(1 << i);
}
```
**Use Case**: Disable a flag in a bitmask.

### 4. Toggling a Bit
To flip the `i`-th bit:
- Use `n ^ (1 << i)`.
```java
int toggleBit(int n, int i) {
    return n ^ (1 << i);
}
```
**Use Case**: Switch a state in a binary configuration.

### 5. Getting the Lowest Set Bit
To find the rightmost 1:
- Use `n & -n` (works due to two’s complement: `-n = ~n + 1`).
```java
int lowestSetBit(int n) {
    return n & -n;
}
```
**Use Case**: Extract the least significant bit for algorithms like Fenwick Trees.

**Pitfall**: Be cautious with negative numbers, as Java uses two’s complement. Always test edge cases (e.g., `n = 0`, negative numbers).

## Step 3: XOR Magic

XOR is a star in bit manipulation due to its properties:
- **A ^ A = 0** (self-cancellation).
- **A ^ 0 = A** (identity).
- **Commutative/Associative**: Order doesn’t matter.

### Example: Single Number (LeetCode #136)
**Problem**: Find the number that appears once in an array where others appear twice.
```java
public class SingleNumber {
    public int singleNumber(int[] nums) {
        int result = 0;
        for (int num : nums) {
            result ^= num;
        }
        return result;
    }
}
```
**Intuition**: Pairs cancel out (`A ^ A = 0`), leaving the single number.

**Use Case**: Find missing or unique elements in arrays.

**Pitfall**: Ensure the problem guarantees exactly one single number. XOR won’t work if numbers appear an odd number of times other than 1.

## Step 4: Advanced Techniques

### 1. Counting Set Bits
To count the number of 1s in a number’s binary representation:
```java
int countSetBits(int n) {
    int count = 0;
    while (n != 0) {
        count += n & 1;
        n >>>= 1;  // Use unsigned right shift to handle negative numbers
    }
    return count;
}
```
**Optimization**: Use `n & (n - 1)` to clear the lowest set bit each iteration:
```java
int countSetBitsOptimized(int n) {
    int count = 0;
    while (n != 0) {
        n &= (n - 1);  // Clear the lowest set bit
        count++;
    }
    return count;
}
```
**Use Case**: Hamming weight (LeetCode #191).

### 2. Finding Missing Number (LeetCode #268)
**Problem**: Find the missing number in `[0, n]` where one number is missing.
```java
public class MissingNumber {
    public int missingNumber(int[] nums) {
        int result = nums.length;
        for (int i = 0; i < nums.length; i++) {
            result ^= i ^ nums[i];
        }
        return result;
    }
}
```
**Intuition**: XOR indices and values; pairs cancel, leaving the missing number.

### 3. Single Number II (LeetCode #137)
**Problem**: Every number appears three times except one. Find the single number.
```java
public class SingleNumberII {
    public int singleNumber(int[] nums) {
        int ones = 0, twos = 0;
        for (int num : nums) {
            ones = (ones ^ num) & ~twos;
            twos = (twos ^ num) & ~ones;
        }
        return ones;
    }
}
```
**Intuition**: Track numbers appearing once and twice using two variables. Bits in `ones` represent numbers appearing once mod 3.

**Key Insight**: For numbers appearing k times, generalize with bit counting or state machines.

## Step 5: Philosophy of Bit Manipulation

**Mindset**:
- **Think in Binary**: Visualize numbers as bit patterns, not decimals.
- **Pattern Recognition**: Look for problems involving pairs, uniqueness, or binary properties.
- **Minimalism**: Bit manipulation often reduces space complexity to O(1).

**Pitfalls**:
- **Sign Bit**: Java’s `int` is signed, so right shifts (`>>`) preserve the sign. Use `>>>` for unsigned shifts.
- **Overflow**: Be cautious with large numbers, as Java’s `int` is 32 bits.
- **Edge Cases**: Test for `0`, negative numbers, and maximum values (`Integer.MAX_VALUE`).

**Deep Knowledge**:
- Bit manipulation is about isolating, flipping, or counting specific bits.
- Combine with other techniques (e.g., two-pointers, hash maps) for hybrid problems.
- Understand two’s complement for negative numbers: `-n = ~n + 1`.

## Step 6: Practical Use Cases

1. **Bitmasks**: Represent sets or flags (e.g., permissions in a system).
2. **Optimization**: Swap two numbers without a temporary variable:
```java
void swap(int[] arr, int i, int j) {
    arr[i] ^= arr[j];
    arr[j] ^= arr[i];
    arr[i] ^= arr[j];
}
```
3. **Encoding/Decoding**: Compress multiple values into a single integer.
4. **LeetCode Problems**:
   - **Single Number** (#136, #137, #260).
   - **Missing Number** (#268).
   - **Number of 1 Bits** (#191).
   - **Reverse Bits** (#190).
   - **Bitwise AND of Numbers Range** (#201).

## Step 7: Practice Plan

1. **Beginner**: Solve Single Number (#136) and Missing Number (#268).
2. **Intermediate**: Tackle Number of 1 Bits (#191) and Reverse Bits (#190).
3. **Advanced**: Solve Single Number II (#137) and Bitwise AND of Numbers Range (#201).
4. **Challenge**: Try Subsets (#78) using bitmasks to generate all subsets.

## Step 8: Mind Map for Revision

Below is a textual representation of a mind map to summarize key concepts. You can visualize it using tools like Mermaid or draw it manually.

```mermaid
graph TD
    A[Bit Manipulation in Java] --> B(Basics)
    A --> C(Operators)
    A --> D(Techniques)
    A --> E(Use Cases)
    A --> F(Pitfalls)
    A --> G(LeetCode Problems)

    B --> B1[Bits: 0 or 1]
    B --> B2[Binary Representation]
    B --> B3[Two’s Complement]

    C --> C1[AND (&)]
    C --> C2[OR (|)]
    C --> C3[XOR (^)]
    C --> C4[NOT (~)]
    C --> C5[Left Shift (<<)]
    C --> C6[Right Shift (>>)]
    C --> C7[Unsigned Right Shift (>>>)]

    D --> D1[Check Bit]
    D --> D2[Set Bit]
    D --> D3[Clear Bit]
    D --> D4[Toggle Bit]
    D --> D5[Count Set Bits]
    D --> D6[Lowest Set Bit]

    E --> E1[Bitmasks]
    E --> E2[Optimization (e.g., Swap)]
    E --> E3[Encoding/Decoding]
    E --> E4[Finding Unique/Missing Numbers]

    F --> F1[Sign Bit Issues]
    F --> F2[Overflow]
    F --> F3[Edge Cases (0, Negative)]

    G --> G1[Single Number (#136)]
    G --> G2[Missing Number (#268)]
    G --> G3[Number of 1 Bits (#191)]
    G --> G4[Single Number II (#137)]
    G --> G5[Reverse Bits (#190)]
```

**How to Use the Mind Map**:
- Start at the center (Bit Manipulation).
- Review each branch (Basics, Operators, etc.).
- Drill into subtopics (e.g., XOR properties under Operators).
- Use it to recall techniques before solving problems.

## Conclusion

Bit manipulation is like a Swiss Army knife for programmers. By mastering these techniques, you’ll solve LeetCode problems efficiently and gain a deeper understanding of how computers process data at the lowest level. Practice the problems listed, revisit the mind map, and experiment with binary conversions to internalize the concepts.

Happy coding, and may your bits always align!